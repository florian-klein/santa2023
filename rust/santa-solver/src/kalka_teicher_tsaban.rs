use crate::groups::PermutationGroupIterator;
use crate::permutation::{Permutation, PermutationInfo};

fn to_2_cycle(p: &PermutationInfo) -> Vec<Vec<usize>> {
    let cycles = &p.cycles;  // disjoint cycles of arbitrary length
    // Express p as a product of disjoint 2-cycles and fixed points
    let mut result = Vec::new();
    for cycle in cycles {
        if cycle.len() <= 2 {
            result.push(cycle.clone());
        } else {
            for i in 0..(cycle.len() - 1) {
                result.push(vec![cycle[i], cycle[i + 1]]);
            }
            result.push(vec![cycle[cycle.len() - 1], cycle[0]]);
        }
    }
    result
}

fn to_3_cycle(p: &PermutationInfo) -> Vec<Vec<usize>> {
    if (!p.signum) {
        panic!("Permutation must be even");
    }
    let cycles = &p.cycles;  // disjoint cycles of arbitrary length
    // Express p as a product of disjoint 3-cycles and fixed points
    // TODO: implement for better results
    to_2_cycle(p)
}

pub fn factorize(generators: &Vec<Permutation>, target: &Permutation) -> Option<Vec<Permutation>> {
    let permutation_info = target.compute_info();
    let n = target.len();
    let c = match permutation_info.signum {
        false => 2,
        true => 3,
    };
    // Step 1: Find a short c-cycle in the group generated by generators
    let generator = PermutationGroupIterator::new(generators);
    let mut mu;
    for tau in generator {
        for m in 1..=n {
            // Check whether tau.pow(m) is a c-cycle
            let tau_cycles = tau.pow(m).compute_info().cycles;
            let mut status = 0;
            for cycle in tau_cycles {
                if cycle.len() > 1 {
                    if cycle.len() == c {
                        if status == 0 {
                            status = 1;
                        } else {
                            status = 2;
                            break;
                        }
                    } else {
                        status = 2;
                        break;
                    }
                }
            }
            if status == 1 {
                mu = tau.pow(m);
                break;
            }
        }
    }

    // disjoint cycles of length c
    let C = match permutation_info.signum {
        false => to_2_cycle(&permutation_info),
        true => to_3_cycle(&permutation_info),
    };

    // Step 2: Find short expressions for additional c-cycles<w
    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_2_cycle() {
        let p = Permutation::from_cycles(&vec![vec![1, 2, 3], vec![4, 5]]);
        let result = to_2_cycle(&p.compute_info());
        assert_eq!(result, vec![vec![1, 2], vec![2, 3], vec![3, 1], vec![4, 5]]);
    }
}