use crate::groups::PermutationGroupIterator;
use crate::permutation::{Permutation, PermutationInfo};
use std::collections::HashSet;

fn to_2_cycle(p: &PermutationInfo) -> Vec<Vec<usize>> {
    let cycles = &p.cycles;  // disjoint cycles of arbitrary length
    // Express p as a product of disjoint 2-cycles and fixed points
    let mut result = Vec::new();
    for cycle in cycles {
        if cycle.len() <= 2 {
            result.push(cycle.clone());
        } else {
            for i in 0..(cycle.len() - 1) {
                result.push(vec![cycle[i], cycle[i + 1]]);
            }
            result.push(vec![cycle[cycle.len() - 1], cycle[0]]);
        }
    }
    result
}

fn to_3_cycle(p: &PermutationInfo) -> Vec<Vec<usize>> {
    if !p.signum {
        panic!("Permutation must be even");
    }
    let cycles = &p.cycles;  // disjoint cycles of arbitrary length
    // Express p as a product of disjoint 3-cycles and fixed points
    // TODO: implement for better results
    to_2_cycle(p)
}

pub fn factorize(generators: &Vec<Permutation>, target: &Permutation) -> Option<Vec<Permutation>> {
    let permutation_info = target.compute_info();
    let n = target.len();
    let c = match permutation_info.signum {
        false => 2,
        true => 3,
    };
    // Step 1: Find a short c-cycle in the group generated by generators
    let generator = PermutationGroupIterator::new(generators);
    let mut mu = Permutation::identity(n);
    for tau in generator {
        for m in 1..=n {
            // Check whether tau.pow(m) is a c-cycle
            let tau_pow = tau.pow(m);
            let tau_cycles = tau_pow.compute_info().cycles;
            let mut status = 0;
            for cycle in tau_cycles {
                if cycle.len() > 1 {
                    if cycle.len() == c {
                        if status == 0 {
                            status = 1;
                        } else {
                            status = 2;
                            break;
                        }
                    } else {
                        status = 2;
                        break;
                    }
                }
            }
            if status == 1 {
                // (reisender): shouldn't we leave when mu is assigned?
                mu = tau_pow;
                break;
            }
        }
    }

    // disjoint cycles of length c
    let C = match permutation_info.signum {
        false => to_2_cycle(&permutation_info),
        true => to_3_cycle(&permutation_info),
    };

    // convert C to a set of permutations
    let mut c_set = HashSet::new();
    for cycle in C {
        c_set.insert(Permutation::from_cycles_fixed_per_size(&vec![cycle], n));
    }

    // Step 2: Find short expressions for additional c-cycles
    // todo: keep track of generators to reconstruct word 
    // todo: fix problem with algorithm not finding any additional c-cycles

    let mut a_0 = HashSet::new();       // A_{l-1}, previous iteration
    let mut a_1 = HashSet::new();       // A_l, current iteration
    let mut a_union = HashSet::new();   // a_0 union A_1 union ... union A_l
    a_0.insert(mu.clone());
    a_union.insert(mu);
    loop {
        for gen in generators {
            a_1.clear();
            let s_i = gen;
            let s_i_inv = s_i.inverse();
            for a in &a_0 {
                // calculate s_i^eps * a * s_i^-eps and check membership
                let perm_eps_pos = s_i_inv.compose(&a.compose(&s_i));
                let perm_eps_neg = s_i.compose(&a.compose(&s_i_inv));

                // A_union = (a_0 union a_1 union ... union A_{l-1}) at this point
                if !a_union.contains(&perm_eps_pos) && !a_1.contains(&perm_eps_pos) {
                    a_1.insert(perm_eps_pos);
                }
                if !a_union.contains(&perm_eps_neg) && !a_1.contains(&perm_eps_neg) {
                    a_1.insert(perm_eps_neg);
                }
            }
            // add A_{l} to A_union by extending A_union
            // reassign s.t. we can reach A_{l} in next iteration A_{l+1}
            a_union.extend(a_1.clone());
            std::mem::swap(&mut a_0, &mut a_1);

            // check if C is contained 
            if a_union.is_superset(&c_set) {
                // Step 3: Find a short expression for target
                let mut result = Vec::new();
                for a in a_union {
                    result.push(a);
                }
                return Some(result);
            }

            // if a_0 is empty, we have not found a short expression so return
            if a_0.is_empty() {
                eprintln!("No short expression found, set for next iteration is empty");
                return None;
            }

        }
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_2_cycle() {
        let p = Permutation::from_cycles(&vec![vec![1, 2, 3], vec![4, 5]]);
        let result = to_2_cycle(&p.compute_info());
        assert_eq!(result, vec![vec![1, 2], vec![2, 3], vec![3, 1], vec![4, 5]]);
    }

    #[test]
    fn factorize_simple(){
        let gen1 = Permutation::parse_permutation_from_cycle("(1,2)", 3);
        let gen2 = Permutation::parse_permutation_from_cycle("(2,3)", 3);
        let generators = vec![gen1, gen2];
        let target = Permutation::new(vec![3, 1, 2]);
        let result = factorize(&generators, &target).unwrap();
        assert_eq!(result, vec![Permutation::new(vec![2, 1, 3]), Permutation::new(vec![1, 2, 3])]);
    }
}
