use crate::groups::PermutationGroupIterator;
use crate::permutation::{Permutation, PermutationInfo};
use std::collections::HashSet;

fn to_2_cycle(p: &PermutationInfo) -> Vec<Vec<usize>> {
    let cycles = &p.cycles;  // disjoint cycles of arbitrary length
    // Express p as a product of disjoint 2-cycles and fixed points
    let mut result = Vec::new();
    for cycle in cycles {
        if cycle.len() == 1 {
            continue;
        } else if cycle.len() == 2 {
            result.push(cycle.clone());
        } else {
            for i in 0..(cycle.len() - 1) {
                result.push(vec![cycle[i], cycle[i + 1]]);
            }
            result.push(vec![cycle[cycle.len() - 1], cycle[0]]);
        }
    }
    result
}

fn to_3_cycle(p: &PermutationInfo) -> Vec<Vec<usize>> {
    if !p.signum {
        panic!("Permutation must be even");
    }
    let cycles = &p.cycles;  // disjoint cycles of arbitrary length
    // Express p as a product of disjoint 3-cycles and fixed points
    // TODO: implement for better results
    to_2_cycle(p)
}

fn find_c_cycle(generators: &Vec<Permutation>, c: usize, n: usize) -> Option<Permutation> {
    let generator = PermutationGroupIterator::new(generators);
    let mut mu = Permutation::identity(n);
    'outer: for tau in generator {
        'inner: for m in 1..=n {
            // Check whether tau.pow(m) is a c-cycle
            let tau_pow = tau.pow(m);
            let tau_cycles = tau_pow.compute_info().cycles;
            let mut found = false;
            for cycle in tau_cycles {
                if cycle.len() > 1 {
                    if cycle.len() == c {
                        if found {
                            continue 'inner;
                        } else {
                            found = true;
                        }
                    } else {
                        continue 'inner;
                    }
                }
            }
            if found {
                mu = tau_pow;
                break 'outer;
            }
        }
    }
    Some(mu)
}

pub fn factorize(generators: &Vec<Permutation>, target: &Permutation) -> Option<Vec<Permutation>> {
    let permutation_info = target.compute_info();
    let n = target.len();
    let c = match permutation_info.signum {
        false => 2,
        true => 3,
    };
    // Step 1: Find a short c-cycle in the group generated by generators
    // todo: in gen decomp word
    let mu = match find_c_cycle(generators, c, n) {
        Some(mu) => mu,
        None => {
            eprintln!("No short c-cycle found");
            return None;
        }
    };

    // disjoint cycles of length c
    let C = match permutation_info.signum {
        false => to_2_cycle(&permutation_info),
        true => to_3_cycle(&permutation_info),
    };

    // convert C to a set of permutations
    let mut c_set = HashSet::new();
    for cycle in C {
        c_set.insert(Permutation::from_cycles_fixed_per_size(&vec![cycle], n));
    }

    // Step 2: Find short expressions for additional c-cycles
    // todo: keep track of generators to reconstruct word 
    // todo: fix problem with algorithm not finding any additional c-cycles

    /*
    Step 2: Find short expressions for additional c-cycles.
    A0 ← {μ};
    For l = 1, 2, . . . : // loop {...}
        Al ← ∅;
        For each i ∈ {1,...,k}, , // iterate over all gens
            for each each a ∈ Al−1: // iterate over all previously new perms
                If s−ǫasǫ ∈/ A_union union A_l, add s−ǫasǫ to Al;
        add Al to a_union
        When C ⊆ A0 ∪ · · · ∪ Al: End Step 2. // end loop here
    */

    let mut a_0: HashSet<Permutation> = HashSet::new();       // A_{l-1}, previous iteration
    let mut a_l : HashSet<Permutation> = HashSet::new();       // A_l, current iteration
    let mut a_union: HashSet<Permutation> = HashSet::new();   // a_0 union A_1 union ... union A_l
    a_0.insert(mu.clone());
    a_union.insert(mu);
    loop {
        a_l.clear();
        for gen in generators {
            //println!("\nUsing generator (a = ):{:?}", gen);
            let s_i = gen;
            let s_i_inv = &s_i.inverse();
            //println!("a_old: {:?}", a_0);
            for a in &a_0 {
                // calculate s_i^eps * a * s_i^-eps and check membership
                // TODO: Puzzles currently automatically add the inverse of each move to the set of moves. Either change this or only check the first case below
                let perm_eps_pos = s_i_inv.compose(&a.compose(s_i));
                let perm_eps_neg = s_i.compose(&a.compose(s_i_inv));
                //println!("perm_eps_pos: {:?}", perm_eps_pos);
                //println!("perm_eps_neg: {:?}", perm_eps_neg);

                // A_union = (a_0 union a_1 union ... union A_{l-1}) at this point
                if !a_union.contains(&perm_eps_pos) && !a_l.contains(&perm_eps_pos) {  // Is the a_l check necessary?
                    // todo: track word representation
                    a_l.insert(perm_eps_pos.clone());
                    //println!("Inserting positive");
                }
                if !a_union.contains(&perm_eps_neg) && !a_l.contains(&perm_eps_neg) {
                    // todo: track word representation
                    a_l.insert(perm_eps_neg);
                    //println!("Inserting negative");
                }
            }
        } // end of l in 1 ...
        // check if we could find elements in next iteration
        if a_l.is_empty() {
            //println!("a_union: {:?}", a_union);
            eprintln!("Error: A_l is empty");
            return None;
        }
        // add A_{l} to A_union by extending A_union
        // reassign s.t. we can reach A_{l} in next iteration A_{l+1}
        // Move items out of a_l into a_union
        a_union.extend(a_l.iter().map(|x| x.clone()));
        //println!("a_l before: {:?}", a_l);
        std::mem::swap(&mut a_0, &mut a_l);
        //println!("a_0 after: {:?}", a_0);
        // Count the elements from c_set missing in a_union
        let mut missing = 0;
        for c in &c_set {
            if !a_union.contains(c) {
                missing += 1;
            }
        }
        if missing == 0 {
            // We have found a short expression for all c-cycles
            // Return a_union
            let result = a_union.iter().map(|x| x.clone()).collect();
            return Some(result);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_2_cycle() {
        let p = Permutation::from_cycles(&vec![vec![1, 2, 3], vec![4, 5]]);
        let result = to_2_cycle(&p.compute_info());
        assert_eq!(result, vec![vec![1, 2], vec![2, 3], vec![3, 1], vec![4, 5]]);
    }

    #[test]
    fn test_find_2_cycle() {
        let gen1 = Permutation::parse_permutation_from_cycle("(1,2)", 3);
        let gen2 = Permutation::parse_permutation_from_cycle("(2,3)", 3);
        let generators = vec![gen1, gen2];
        let result = find_c_cycle(&generators, 2, 3);
        assert!(result.is_some());
        let result = result.unwrap();
        assert_eq!(result, Permutation::new(vec![2, 1, 3]));
    }

    #[test]
    fn test_find_2_cycle2() {
        let gen1 = Permutation::parse_permutation_from_cycle("(1,2,4,3)", 4);
        let gen2 = Permutation::parse_permutation_from_cycle("(2,1,3)", 4);
        let generators = vec![gen1, gen2];
        let result = find_c_cycle(&generators, 2, 4);
        assert!(result.is_some());
        let result = result.unwrap();
        assert_eq!(result, Permutation::new(vec![1, 4, 3, 2]));
    }

    #[test]
    fn factorize_simple(){
        let gen1 = Permutation::parse_permutation_from_cycle("(1,2)", 3);
        let gen2 = Permutation::parse_permutation_from_cycle("(2,3)", 3);
        println!("generators: {:?}, {:?}", gen1, gen2);
        let generators = vec![gen1, gen2];
        let target = Permutation::new(vec![1, 3, 2]);
        let result = factorize(&generators, &target).unwrap();
        assert!(result.contains(&target));
    }
}
